## 138.copy-list-with-random-pointer.py

* 思路： 每拷贝一个结点都需要重新声明一个结点类。将每一个拷贝后的结点接在原结点后，然后再从头遍历一遍确定random结点的指向。最后返回奇数结点作为新的拷贝链表。
* 注意： 结点的指向一定要搞明确以及循环时退出的条件
* 时间复杂度=O(n)


## 142.linked-list-cycle-ii.py

* 思路： 快慢两个指针分别走链表，如果走到None说明不存在环。如果两个指针相遇则说明存在环，此时将快指针指向头结点。继续遍历链表，直到快指针与慢指针再次相遇。此时就是环的入口。
* 时间复杂度=O(n)

## 143.reorder-list.py



## 147.insertion-sort-list.py

* 思路：遍历链表中的元素，当前元素与已经排序的链表进行比较，如果小于则插入，如果大于则继续比较。
* 注意：代码的简洁性
* 时间复杂度=O(n^2)

## 148.sort-list.py

* 思路：根据快排的思想，将链表第一个元素作为Pivot，对后面的元素进行比较，形成三个分区，分别是小于Pivot的，等于Pivot的以及大于Pivot的。然后对小于以及大于的分别递归再进行排序。最后串联三者返回。如果小于的为None，则返回Pivot所在的结点。
* 注意：递归要注意返回的条件，以及什么时候进行递归，递归返回的结果如何处理。
* 时间复杂度=O(nlogn)

