## 27.remove-element.py

* 注意各种特殊情况的判断，比如[1]/1, [2,2,2]/2, [4,5]/5这些情况
* 其实思路与答案的思路是相同的，但是判断条件想错了。可以利用i与last相遇作为结束循环的条件，且last就能当做最终length的长度了。
* 注意python代码的简洁，多个元素复制可以写在同一行。更加pythonic。

## 53.maximum-subarray.py

* 思路：如果累加的和不如当前元素大，那么直接从当前元素开始。
* 注意length=1或0的输入情况判断
* 时间复杂度=O(n)，空间复杂度O(1)。只需要遍历一遍数组

## 66.plus-one.py

* 思路：末尾<9，直接+1后返回。如果=9，赋值为0，考虑下一位
* 注意: [9],[9,9]这种特殊情况
* 时间复杂度=O(n), 空间复杂度=O(n)，需要额外相等的空间存储逆序的数组。也可以考虑in-place实现。

## 88.merge-sorted-array.py

* 思路：第一反应是从前往后插入，但其实应该从后往前插入。最后一位大的就一定是最大的，可以直接插入当前最末尾。然后固定末尾，继续往前插入。
* 注意：需要判断[0],1,[1],1 这种情形。
* 时间复杂度=O(n)，空间复杂度=O(1)

## 118.pascals-triangle.py

* 思路：使用定义，当前元素等于头顶两元素之和。如果在位置在当前行的第一个与最后一个，则为1
* 注意：这种纯数学的题目，要学会考虑如何将数学定义转换为编程语言
* 时间复杂度=O($n^2$),空间复杂度=O(1)

## 119.pascals-triangle-ii.py

* 思路：使用公式，利用组合数求每个位置的元素。需要额外写一个求阶乘的函数，可以使用递归实现。
* 时间复杂度=O(n^2)

## 121.best-time-to-buy-and-sell-stock.py

* 思路：使用三个变量分别记录买入位置，当前利润，最大利润。遍历一次数组，即可求得最大利润。
* 时间复杂度=O(n)

## 122.best-time-to-buy-and-sell-stock-ii.py

* 思路：如果能够多次买入卖出的话，最大利润等于一阶差分结果大于0的元素之和。贪心算法
* 时间复杂度=O(n)

## 167.two-sum-ii-input-array-is-sorted.py

* 思路：利用数组是有序的这一性质，首尾之和如果大了，则移动末尾元素，首尾之和如果小了则移动开头元素。
* 注意：遇到排序的数组，一定要充分利用这个性质，解题时如果没有利用到这个性质，则一定不是最优的解法。
* 时间复杂度=O(n)

## 169.majority-element.py

* 思路：majority-element出现次数大于数组长度的一半，使用变量cnt来记录当前出现次数最多的元素。如果下一个元素不同，cnt-=1，如果cnt=0，则更换元素。
* 注意： 充分利用定义
* 时间复杂度=O(n)

## 189.rotate-array.py

* 思路：最简单的利用python slice的特性与数组拼接。

## 218.contains-duplicate.py

* 思路：使用额外的空间存储数字出现的次数，也可以使用python特性如set()函数
* 时间复杂度=O(n),空间复杂度=O(n)

## 219.contains-duplicate-ii.py

* 思路：使用额外空间存储数字出现的位置，如果再一次出现，比较两者位置的差。满足条件返回，不满足条件更新位置。
* 时间复杂度=O(n),空间复杂度=O(n)

## 268.missing-number.py

* 思路：纯数学思路，缺少的数字=应有的和 - 现有的和
## 283.move-zeroes.py

* 思路：遇到0，pos不变。非0的元素则与当前所指的第一个0元素交换，然后pos+=1。

	​	
## 414.third-maximum-number.py

* 思路：利用空间换取时间，使用一个len=3的数组保存最大的前3个元素。
* 时间复杂度=O(n),空间复杂度=O(1)

	​	
## 448.find-all-numbers-disappeared-in-an-array.py

* 思路：数组中的元素都在1~n范围内，则可以把数组中的元素当做下标，把对应下标的元素标记一下。没有出现的数字就是没有对应下标的元素，也即没被标记的元素。
* 时间复杂度=O(n),空间复杂度=O(1)

## 485.max-consecutive-ones.py

* 思路: 只需要记录1连续的次数，以及最大的1连续次数即可
* 时间复杂度=O(n),空间复杂度=O(1)

## 532.k-diff-pairs-in-an-array.py

* 思路：使用两个set记录, 一个set记录满足条件的pair中较小的那个数，一个记录满足条件的pair中数组中所有的元素。只记录较小的那个使用set的特性即可以去重。
* 时间复杂度=O(n),空间复杂度=O(n)

## 561.array-partition-i.py

* 思路： 根据定义，最大值应该是排序后奇数位元素之和
* 时间复杂度=O(nlogn)


## 566.reshape-the-matrix.py

* 思路：主要是推断reshape后i,j对应的新的位置
* 注意：python生成matrix不能用[[0]\*r]\*c的方式
* 时间复杂度=O(r\*c)，空间复杂度=O(r*c)

## 605.can-place-flowers.py

* 思路：只有当前为0且左右均为0时当前位置才可放置。
* 注意：边界情况要考虑进去，即开头为0以及结尾为0的时候
* 时间复杂度=O(n)

## 628.maximum-product-of-three-numbers.py

* 思路：记录top3的三个元素以及最小的两个元素，因为要考虑负数的情况，则最小的两个负数与最大的一个整数的乘积要与最大的三个整数乘积进行比较。
* 时间复杂度=O(n)

## 643.maximum-average-subarray-i.py

* 思路：使用一个变量记录连续k长的subarray的和的最大值。
* 时间复杂度=O(n)


## 661.image-smoother.py

* 思路：对于矩阵第（i,j）位元素，i-1，i+1,j-1,j+1不满足条件时不加，其余组合全部加起来。
* 注意：对于这种复杂条件判断问题，可以转换为一种通用的表达方式。
* 时间复杂度=O(m*n)，空间复杂度=O(m\*n)

# List

## 160.intersection-of-two-linked-list.py

* 思路： 先得到链表的长度，然后长的链表先走完多余部分。之后两个链表一起走。
* 时间复杂度=O(m+n)

## 2.add-two-number.py

* 思路：考虑好进位以及数字长度不一的情况即可。
* 注意：在实现的时候，其实有更简单的方式，第一版实现完全没有任何简洁可言。。。既然要遍历两个链表，可以在全局循环里面判断链表是否到尾部。以及对于进位的考虑，不需要判断是否大于9。也不需要重复设置flag。好好品味第二种实现的简洁之处吧。
* 时间复杂度=O(n)


## 61.rotate-list.py

* 思路：一共分三步走，第一遍历链表得到链表长度，将尾结点与头结点相连。得到链表长度后计算得到需要从头结点向后走几步得到新的头结点。得到新的头结点后断开环。
* 注意：在实现中尾结点与头结点相连是一个trick。节省代码量。
* 时间复杂度=O(n)
## 82.remove-duplicates-from-sorted-list.py

* 思路：重新构建一个链表，比较当前与下一个元素，直到元素不同位置，前一个节点指向不同的当前节点。因为是有重复的元素就要全部删掉。第一个实现是有重复的元素只保留一个。
* 注意： 在这种需要重新构建链表的题目中，可以声明一个头结点，最终的结果返回头结点的next结点。这种思路要习惯。
* 时间复杂度=O(n)

