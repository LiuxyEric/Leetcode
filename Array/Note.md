## 27.remove-element.py

* 注意各种特殊情况的判断，比如[1]/1, [2,2,2]/2, [4,5]/5这些情况
* 其实思路与答案的思路是相同的，但是判断条件想错了。可以利用i与last相遇作为结束循环的条件，且last就能当做最终length的长度了。
* 注意python代码的简洁，多个元素复制可以写在同一行。更加pythonic。

## 53.maximum-subarray.py

* 思路：如果累加的和不如当前元素大，那么直接从当前元素开始。
* 注意length=1或0的输入情况判断
* 时间复杂度=O(n)，空间复杂度O(1)。只需要遍历一遍数组

## 66.plus-one.py

* 思路：末尾<9，直接+1后返回。如果=9，赋值为0，考虑下一位
* 注意: [9],[9,9]这种特殊情况
* 时间复杂度=O(n), 空间复杂度=O(n)，需要额外相等的空间存储逆序的数组。也可以考虑in-place实现。

## 88.merge-sorted-array.py

* 思路：第一反应是从前往后插入，但其实应该从后往前插入。最后一位大的就一定是最大的，可以直接插入当前最末尾。然后固定末尾，继续往前插入。
* 注意：需要判断[0],1,[1],1 这种情形。
* 时间复杂度=O(n)，空间复杂度=O(1)

## 118.pascals-triangle.py

* 思路：使用定义，当前元素等于头顶两元素之和。如果在位置在当前行的第一个与最后一个，则为1
* 注意：这种纯数学的题目，要学会考虑如何将数学定义转换为编程语言
* 时间复杂度=O($n^2$),空间复杂度=O(1)

## 119.pascals-triangle-ii.py

* 思路：使用公式，利用组合数求每个位置的元素。需要额外写一个求阶乘的函数，可以使用递归实现。
* 时间复杂度=O(n^2)

## 121.best-time-to-buy-and-sell-stock.py

* 思路：使用三个变量分别记录买入位置，当前利润，最大利润。遍历一次数组，即可求得最大利润。
* 时间复杂度=O(n)
